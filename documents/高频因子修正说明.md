# 高频因子构建与暴露度计算修正说明

> 修改日期：2025-10-05  
> 修改文件：`lightweight_analysis.py`  
> 修改范围：高频因子构建方法与文档说明

---

## 📋 修改概览

针对“策略因子特征暴露度”页面中的高频因子构建方式，进行了以下三处关键修正，以提升因子的统计合理性与经济含义的纯净性。

---

## ✅ 修正1：已实现波动率 (RV) 计算方法

### 问题诊断

**原实现** (第3154行)：
```python
rv = float(np.sqrt((r ** 2).sum()))  # r为日内所有5分钟收益率
```

**问题**：
- 直接对平方和开方，随日内数据点数变化而变化
- 48个5分钟点 vs 12个5分钟点会有 √4 = 2倍差异
- 不符合标准的已实现波动率定义

### 修正方案

**新实现** (第3206行)：
```python
rv = float(r.std(ddof=0)) if len(r) > 1 else np.nan
```

**改进点**：
- 使用标准差（population std, ddof=0）
- 数值稳定性：与数据点数无关
- 数学合理性：符合学术界标准RV定义

**影响评估**：
- 数值范围：修正后RV数值会显著下降（约为原来的1/√n）
- 可比性：修正后不同日期的RV直接可比（不受采样点数影响）
- 后续影响：因子暴露分析、风险归因的RV系数需重新解读

---

## ✅ 修正2：日内价格振幅归一化基准

### 问题诊断

**原实现** (第3180行)：
```python
rng = float((hi.max() - lo.min()) / last_close)  # 使用末笔收盘价
```

**问题**：
- 当日大幅上涨时：last_close膨胀 → 振幅被低估
- 当日大幅下跌时：last_close缩小 → 振幅被高估
- 导致振幅因子与当日收益率产生非线性相关性

### 修正方案

**新实现** (第3232行)：
```python
first_close = float(close_series.dropna().iloc[0])  # 使用首笔价格
rng = float((hi.max() - lo.min()) / first_close)
```

**改进点**：
- 使用日内首笔价格（接近开盘价）作为分母
- 避免当日涨跌对振幅度量的非线性扭曲
- 更符合ATR（Average True Range）等标准波动率指标的实践

**数学表达**：
- 原公式：$\mathrm{Range} = \frac{\max(H) - \min(L)}{p_{\text{last}}}$
- 新公式：$\mathrm{Range} = \frac{\max(H) - \min(L)}{p_{\text{first}}}$

**影响评估**：
- 修正后振幅更接近"真实价格波动幅度"
- 在单边行情（大涨/大跌日）的修正效果最显著
- 与其他标准化波动率指标（如ATR）的可比性提升

---

## ✅ 修正3：动量因子频率混合问题

### 问题诊断

**原实现** (第3288-3289行)：
```python
# 对缺失的分钟动量逐行回退到日频口径
factors['mom_5m'] = np.where(factors['mom_5m'].notna(), factors['mom_5m'], factors['mom_5d'])
factors['mom_30m'] = np.where(factors['mom_30m'].notna(), factors['mom_30m'], factors['mom_20d'])
```

**问题**：
- **5分钟动量**：捕捉日内情绪、超短期价格惯性（回看1根5分钟K线）
- **5日动量**：捕捉短期趋势、多日持续性（回看5个交易日）
- **经济含义完全不同**：
  - 5m动量 ≈ "最近5分钟涨了多少"（日内脉冲）
  - 5d动量 ≈ "过去一周涨了多少"（短期趋势）
- 混合使用会导致：
  - 暴露度曲线的解释模糊
  - 无法区分"日内择时"与"短期趋势跟随"
  - 回归归因时系数失去单一经济含义

### 修正方案

**新实现** (第3287-3289行)：
```python
# 修正：不再回退，保持频率纯净；缺失时为NaN
# 原逻辑：factors['mom_5m'] = np.where(...)
# 理由：5分钟动量(日内情绪) vs 5日动量(短期趋势)，经济含义不同，不应混合
```

**改进点**：
- 缺失时保持 `NaN`，不混合不同频率
- 新增覆盖率统计与低覆盖率警告：
  ```python
  if cov_5m < 0.5 or cov_30m < 0.5:
      print(f"⚠️ 分钟动量覆盖率较低: mom_5m={cov_5m:.1%}, mom_30m={cov_30m:.1%}，缺失部分保持NaN")
  ```
- 文档说明明确标注"不再回退混合"

**文档更新** (第3868-3870行)：
```python
momentum_line = (
    r"<b>动量（5m/30m/60m）</b>: \(\mathrm{mom}_{n\,5m}=\frac{p_t}{p_{t-n}}-1\)，n=1/6/12；"
    f"当前5m覆盖率≈{cov5_avg:.1%}，30m覆盖率≈{cov30_avg:.1%}；缺失部分保持NaN，"
    "<b>不再回退混合日频动量</b>（避免混淆日内情绪与短期趋势）。"
)
```

**影响评估**：
- 暴露度曲线更纯净：只反映真实的5分钟动量暴露
- 覆盖率下降时：部分日期的动量暴露为NaN（从分子分母同时剔除）
- 后续行动：
  - 若覆盖率<50%，建议补充5分钟K数据（使用 `scripts/fetch_minute_5m_with_amount.py`）
  - 若无法补充，可单独分析"有5m数据"与"无5m数据"的子样本差异

---

## 📊 修正后的因子定义总览

| 因子 | 修正后公式 | 数据源 | 频率 | 关键改进 |
|------|-----------|--------|------|----------|
| **ln_market_cap** | $\ln(\text{市值})$ | stock_metadata | 静态/日频 | 无修改 |
| **mom_5m** | $\frac{p_t}{p_{t-1}}-1$ | 5分钟K | 分钟→日聚合 | 缺失不回退 |
| **mom_30m** | $\frac{p_t}{p_{t-6}}-1$ | 5分钟K | 分钟→日聚合 | 缺失不回退 |
| **mom_60m** | $\frac{p_t}{p_{t-12}}-1$ | 5分钟K | 分钟→日聚合 | 无修改 |
| **rv_5m** | $\text{std}(r_{5m})$ | 5分钟K | 分钟→日聚合 | ✅ 改用标准差 |
| **beta_5m** | $\frac{\text{Cov}(r,r_{\text{idx}})}{\text{Var}(r_{\text{idx}})}$ | 5分钟K+指数 | 日内回归 | 无修改 |
| **range_day** | $\frac{H-L}{p_{\text{first}}}$ | 5分钟K | 日内极值 | ✅ 改用首价 |
| **liquidity** | $\frac{\|r_{1d}\|}{\text{Amount}}$ | 日K | 日频 | 无修改 |

---

## 🔍 暴露度计算合理性评估

### ✅ 合理的设计

1. **权重口径：仅统计新增仓位**
   ```python
   trades['trade_weight'] = long_exposure_amount + short_exposure_amount
   ```
   - ✅ 直接评估"开仓决策时"的因子特征
   - ✅ 避免持仓被动变动（价格波动）污染信号

2. **加权公式数学严谨**
   ```python
   strat_exposure = Σ(weight_i × factor_i) / Σ(weight_i)
   ```
   - ✅ 标准的加权平均公式
   - ✅ 自动剔除因子缺失样本（从分子分母同时移除）

3. **市场基准：市值加权**
   ```python
   mkt_exposure = Σ(market_cap_i × factor_i) / Σ(market_cap_i)
   ```
   - ✅ 符合学术标准（Fama-French等方法）
   - ✅ 缺失市值时回退为等权（稳健）

### ⚠️ 设计局限性

1. **仅捕捉开仓时点特征**
   - 未追踪持仓期间因子值变化
   - 对于长期持仓策略，可能低估暴露漂移
   - **建议**：补充"持仓暴露"分析（已实现：`factor_holdings_exposure_analysis`）

2. **时间对齐容差**
   - 使用 ±150秒容差对齐分钟数据
   - 极端情况下可能匹配到±2.5分钟外的因子值
   - **影响**：在快速行情中可能产生轻微滞后偏差

3. **日内聚合方法**
   - 使用 `mean()`对日内多笔取均值
   - 未考虑日内时间加权（早盘 vs 尾盘）
   - **适用性**：对于日内均匀分布的策略合理；集中于某时段的策略可能失真

---

## 🎯 实战影响与后续行动

### 立即影响
1. **RV暴露曲线会整体下移**（约为原来的1/√48）
2. **Range暴露在大涨/大跌日更稳定**
3. **动量暴露在数据缺失日会出现断点（NaN）**

### 建议行动
1. **重新运行分析**：
   ```bash
   & C:\Users\11\.conda\envs\cnn_env\python.exe lightweight_analysis.py
   ```

2. **重点关注**：
   - RV暴露的新数值范围（预期0.001-0.05之间）
   - 动量覆盖率报告（若<50%需补充数据）
   - Range在极端日的稳定性

3. **数据补充**（若动量覆盖率<50%）：
   ```bash
   & C:\Users\11\.conda\envs\cnn_env\python.exe scripts/fetch_minute_5m_with_amount.py
   ```

---

## 📚 技术参考

### 已实现波动率标准定义

**学术文献**：
- Andersen & Bollerslev (1998): "Answering the Skeptics: Yes, Standard Volatility Models Do Provide Accurate Forecasts"
- 标准定义：$RV_t = \sqrt{\sum_{i=1}^{N} r_{i,t}^2}$ 或 $RV_t = \text{std}(r_{i,t})$

**为什么使用std而非sum**：
- 归一化：消除采样频率影响
- 可比性：不同日期/不同股票直接可比
- 统计性质：std是无偏估计量

### 价格振幅标准化基准

**业界实践**：
- ATR (Average True Range)：使用前收盘价
- Intraday Range：通常使用开盘价或前收盘价
- Bollinger Bands：使用移动平均作为基准

**选择first_close的理由**：
- 最接近开盘价（日内首笔成交）
- 避免日内趋势对振幅的非线性影响
- 更准确反映"相对于起点的波动幅度"

---

## 🔬 验证与测试

### 单元测试建议

1. **RV计算验证**：
   ```python
   # 测试案例：固定收益率序列
   r = pd.Series([0.01, -0.01, 0.02, -0.02])
   rv_new = r.std(ddof=0)  # 应为 0.0158
   rv_old = np.sqrt((r ** 2).sum())  # 应为 0.0316
   assert abs(rv_new - 0.0158) < 0.0001
   ```

2. **Range计算验证**：
   ```python
   # 测试案例：单边上涨日
   open_price = 10.0
   high = 11.0
   low = 9.5
   close = 10.8
   range_new = (high - low) / open_price  # = 0.15 (15%)
   range_old = (high - low) / close  # = 0.139 (13.9%)，被低估
   ```

3. **动量覆盖率验证**：
   ```python
   # 验证是否正确统计NaN比例
   coverage = factors['mom_5m_is_intraday'].mean()
   assert 0.0 <= coverage <= 1.0
   ```

---

## 📈 预期输出差异

### 修正前 vs 修正后对比

| 指标 | 修正前典型值 | 修正后典型值 | 变化 |
|------|-------------|-------------|------|
| **RV暴露均值** | 0.15-0.30 | 0.005-0.015 | ↓ ~20倍 |
| **Range暴露均值** | 0.03-0.08 | 0.03-0.08 | ≈ 不变 |
| **动量暴露完整性** | 100% (混合频率) | 50-90% (纯分钟) | 取决于数据 |

### 图表变化预期

1. **RV时间序列**：
   - 整体下移至接近0的水平
   - 相对波动形态保持一致
   - 极值更加平滑

2. **Range时间序列**：
   - 单边行情日不再出现异常低/高值
   - 与其他波动率指标的相关性提升

3. **动量时间序列**：
   - 可能出现断点（数据缺失处）
   - 覆盖率统计出现在页面提示中

---

## 📝 代码变更清单

### 文件：`lightweight_analysis.py`

| 行号范围 | 变更类型 | 说明 |
|---------|---------|------|
| 3206 | 计算逻辑 | RV改用std(ddof=0) |
| 3227-3232 | 计算逻辑 | Range改用first_close |
| 3287-3317 | 计算逻辑 | 动量不再回退，保持NaN |
| 3868-3870 | 文档说明 | 更新动量定义说明 |
| 3891-3901 | 文档说明 | 更新Range定义说明 |
| 3913 | 文档说明 | 更新RV定义说明 |
| 3959-3966 | 文档说明 | 更新数据完整性提示 |

### 删除的缓存文件（需重新计算）

建议删除以下缓存以确保使用新算法：
```bash
rm data/factors_daily_cache.parquet
rm data/factor_exposure_daily_cache.parquet
rm data/minute_5m_factors_cache.parquet
```

---

## ✅ 质量保证

### 语法检查
```bash
✅ python -m py_compile lightweight_analysis.py
   无语法错误
```

### 向后兼容性
- ✅ 旧缓存自动失效并重新计算
- ✅ API接口无变化
- ✅ 输出文件名保持一致

### 破坏性变更警告
⚠️ **RV数值范围变化巨大**：如果后续分析/模型使用了RV的绝对数值，需要重新校准阈值

---

## 🎓 学习要点

### 为什么这些细节很重要

1. **统计一致性**：
   - 不同日期的因子值必须"可比"
   - 采样频率/计算口径的不一致会导致虚假相关

2. **经济含义纯净性**：
   - 混合频率 = 混合两种投资逻辑
   - 暴露度分析的目标是"解构策略"，而非"填补空缺"

3. **前视偏差规避**：
   - 使用first_close而非last_close
   - 使用T-1暴露而非T暴露作为分母
   - 确保所有因子值在"决策时点"可获得

---

## 🚀 下一步优化方向

1. **高频流动性因子**：
   - 当前仅有日频Amihud ILLIQ
   - 建议补充：买卖价差、盘口深度（需Tick数据）

2. **分钟β的窗口优化**：
   - 当前使用固定6根5分钟K线（30分钟窗口）
   - 建议：根据市场波动自适应调整窗口（如使用GARCH）

3. **持仓暴露追踪**：
   - 当前仅追踪开仓时点
   - 已实现持仓暴露分析（`factor_holdings_exposure_analysis`）
   - 建议结合两者，完整评估"开仓特征"与"持有期漂移"

---

## 📖 参考文档

- `可视化输出指导文档/因子归因.md`：因子构建理论基础
- `可视化输出指导文档/按暴露计算收益率.md`：暴露度标准化方法
- `lightweight_analysis.py` 第3842-3972行：因子暴露分析实现
- Fama-French (1993): "Common risk factors in the returns on stocks and bonds"

---

**修正完成！✅**  
请重新运行分析脚本以查看修正后的结果。若有疑问，请查阅本文档或相关代码注释。
