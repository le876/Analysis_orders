# 策略因子特征暴露度：计算与呈现方式完整评估

> 评估日期：2025-10-05  
> 评估文件：`lightweight_analysis.py` (第3981-4495行)  
> 评估范围：暴露度计算逻辑、可视化呈现、多空分解、持仓追踪

---

## 📋 计算链路全景图

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 数据准备层                                                │
├─────────────────────────────────────────────────────────────┤
│ _build_factor_dataset()        → 因子日表 (Code, date, 8因子) │
│ _prepare_trade_flows()         → 交易流水 (仅新增仓位)         │
│ _build_intraday_factor_snapshots() → 分钟因子快照 (±10分钟)   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 时间对齐层                                                │
├─────────────────────────────────────────────────────────────┤
│ merge_asof(tolerance=10min)    → 交易时刻匹配最近因子快照     │
│ merge(on='trade_date')         → 补充当日日频因子            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 暴露度计算层                                              │
├─────────────────────────────────────────────────────────────┤
│ 策略端: Σ(trade_weight × factor) / Σ(trade_weight)          │
│ 市场端: Σ(market_cap × factor) / Σ(market_cap)              │
│ 多空分解: long暴露 / short暴露 / 净暴露                       │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 可视化呈现层                                              │
├─────────────────────────────────────────────────────────────┤
│ 主图: 2×N网格，策略 vs 市场基准                              │
│ 副图1: N×2网格，多头 vs 空头（左右分栏）                     │
│ 副图2: N×2网格，净持仓暴露 vs 市场（左）+ 多空拆分（右）      │
└─────────────────────────────────────────────────────────────┘
```

---

## ✅ 合理设计的细节

### 1. **增量仓位识别算法** (3404-3410行)

```python
# 计算多空方向增量仓位（股数）
trades['delta_long_qty'] = np.maximum(trades['pos_after'], 0.0) - np.maximum(trades['pos_prev'], 0.0)
trades['delta_short_qty'] = np.maximum(-trades['pos_after'], 0.0) - np.maximum(-trades['pos_prev'], 0.0)

# 将股数转换为金额权重
trades['long_exposure_amount'] = (trades['delta_long_qty'] * trades['exec_price']).clip(lower=0.0)
trades['short_exposure_amount'] = (trades['delta_short_qty'].abs() * trades['exec_price']).clip(lower=0.0)
trades['trade_weight'] = trades['long_exposure_amount'] + trades['short_exposure_amount'
```

**✅ 数学严谨性**：
- 使用`max(pos, 0)`分离多空头寸
- 增量 = 事后多头 - 事前多头（仅保留正增量）
- 自动处理复杂场景：
  - 买入平空：delta_short_qty减少
  - 卖出平多：delta_long_qty减少
  - 纯平仓：trade_weight = 0（被剔除）

**✅ 业务合理性**：
- 只统计"新增风险暴露"
- 避免平仓操作污染因子归因
- 符合"评估开仓决策质量"的目标

**示例验证**：
```
场景1：空头100股 → 买入150股
  pos_prev = -100, pos_after = +50
  delta_long = max(50, 0) - max(-100, 0) = 50 - 0 = 50 ✅
  delta_short = max(-50, 0) - max(100, 0) = 0 - 100 = -100 → abs = 100 ✅
  trade_weight = 50×price (新增多头) ✅ (空头平仓不计权重)

场景2：多头100股 → 卖出50股
  pos_prev = 100, pos_after = 50
  delta_long = max(50, 0) - max(100, 0) = 50 - 100 = -50 → clip(0) = 0 ✅
  trade_weight = 0 (纯平仓，被剔除) ✅
```

---

### 2. **时间对齐策略** (3567-3573行)

```python
merged_code = pd.merge_asof(
    left,
    right,
    left_on='Timestamp',
    right_on='datetime',
    direction='backward',
    tolerance=pd.Timedelta(minutes=10)
)
```

**✅ 向后查找（backward）**：
- 避免前视偏差：只使用成交时刻之前的因子值
- 符合真实决策场景

**⚠️ 容差设置（10分钟）**：
- **优点**：兼容数据稀疏场景
- **风险**：极端情况下可能匹配到10分钟前的因子
- **建议优化**：
  ```python
  # 分层容差：先严格（2分钟），再宽松（10分钟）
  merged_strict = pd.merge_asof(..., tolerance=pd.Timedelta(minutes=2))
  merged_loose = pd.merge_asof(..., tolerance=pd.Timedelta(minutes=10))
  merged_strict['match_quality'] = 'strict'
  merged_loose['match_quality'] = 'loose'
  # 合并并标记匹配质量
  ```

---

### 3. **加权暴露计算** (4025-4034行)

```python
def _weighted_exposure(df: pd.DataFrame, col: str, weight_col: str) -> float:
    g = df.dropna(subset=[col, weight_col])  # 同时剔除因子缺失和权重缺失
    if len(g) == 0:
        return np.nan
    w = g[weight_col].astype(float)
    sw = w.sum()
    if sw <= 0:
        return np.nan
    x = g[col].astype(float)
    return float((w * x).sum() / sw)
```

**✅ 数学完备性**：
- 自动处理缺失值（从分子分母同时剔除）
- 零权重保护（sw <= 0 → NaN）
- 类型安全（强制转float）

**✅ 统计性质**：
- 无偏估计量（只要权重非负）
- 满足线性性质：E[aX + bY] = aE[X] + bE[Y]

**⚠️ 潜在问题：极端权重**
```python
# 当前实现未处理权重极值
# 场景：某日单笔大额交易主导当日暴露
```

**建议优化**：
```python
def _weighted_exposure_robust(df, col, weight_col, winsorize_pct=0.95):
    g = df.dropna(subset=[col, weight_col])
    if len(g) == 0:
        return np.nan
    w = g[weight_col].astype(float)
    # 权重winsorize：限制单笔最大权重不超过总权重的X%
    w_cap = w.clip(upper=w.quantile(winsorize_pct))
    sw = w_cap.sum()
    if sw <= 0:
        return np.nan
    x = g[col].astype(float)
    return float((w_cap * x).sum() / sw)
```

---

### 4. **市场基准构建** (4064-4073行)

```python
def _market_exposure(factors_day: pd.DataFrame, col: str) -> float:
    g = factors_day.dropna(subset=[col])
    if len(g) == 0:
        return np.nan
    if 'market_cap' in g.columns and g['market_cap'].notna().any():
        w = g['market_cap'].astype(float).clip(lower=0)
        sw = w.sum()
        if sw > 0:
            return float((w * g[col].astype(float)).sum() / sw)
    return float(g[col].astype(float).mean())  # 回退：等权
```

**✅ 学术标准**：
- 市值加权是Fama-French等因子研究的标准做法
- 回退为等权是稳健的降级策略

**⚠️ 静态市值问题**：
- 当前使用`stock_metadata.parquet`中的静态市值
- **前视偏差**：使用"当前市值"评估"历史日期"的市场基准
- **影响**：市场基准暴露可能不准确，尤其对于市值变化大的股票

**建议改进**：
```python
# 使用时变市值（如果可用）
if 'daily_k_cache.parquet' 中有 market_cap 列:
    使用历史市值（避免前视偏差）
else:
    在说明中明确标注"市场基准使用静态市值，存在前视偏差"
```

---

### 5. **多空方向分解** (4047-4048行)

```python
direction_row[f'long_{col}'] = _weighted_exposure(df_day, col, 'long_exposure_amount')
direction_row[f'short_{col}'] = -_weighted_exposure(df_day, col, 'short_exposure_amount')
```

**⚠️ 符号处理问题**：

**问题场景**：
```
某日开空100万，空头股票的mom_5m = +0.02 (价格上涨)
short_exposure_amount = 100万
_weighted_exposure(..., 'short_exposure_amount') = +0.02
direction_row['short_mom_5m'] = -0.02  # 加了负号

解读：空头在"上涨股票"上的暴露显示为负数
```

**问题**：
- 负号语义不清：到底是"暴露值为负"还是"做空方向"？
- 与"净暴露"的符号逻辑不一致

**建议修正**：
```python
# 方案A：移除负号，用颜色区分方向
direction_row[f'short_{col}'] = _weighted_exposure(df_day, col, 'short_exposure_amount')
# 在图表中：
# - 多头用绿色曲线
# - 空头用红色曲线
# - 不依赖正负号区分方向

# 方案B：改为"有向暴露"（符合会计逻辑）
direction_row[f'short_{col}'] = -_weighted_exposure(df_day, col, 'short_exposure_amount')
# 并在说明中明确：
# "空头暴露取负号，使得净暴露 = 多头暴露 + 空头暴露（含负号）"
```

---

### 6. **可视化布局** (4111-4130行)

**主图：2×N网格** (factor_exposure_light)
```python
cols = 2
rows = (len(show_cols) + cols - 1) // cols  # 上下排列，每行2个因子
fig = make_subplots(rows=rows, cols=cols, subplot_titles=[...])
```

**✅ 设计合理**：
- 紧凑布局，一屏可见多个因子
- 横向对比：策略 vs 市场
- 共享时间轴（hovermode='x unified'）

**⚠️ 图例拥挤问题**：
- 8个因子 × 2条曲线 = 16条线
- 当前图例水平排列（orientation='h'）
- 宽度不足时会重叠

**建议优化**：
```python
fig.update_layout(
    legend=dict(
        orientation='v',  # 改为垂直
        yanchor='top',
        y=0.98,
        xanchor='right',
        x=1.15,  # 放在图表右侧外部
        bgcolor='rgba(255,255,255,0.9)',
        bordercolor='rgba(0,0,0,0.2)',
        borderwidth=1
    )
)
```

---

**副图1：N×2网格（多空分解）** (factor_direction_exposure_light)

**当前布局问题** (4214-4220行)：
```python
cols = 2
rows = len(show_cols)  # 每个因子占一整行！
fig = make_subplots(
    rows=rows,
    cols=cols,
    shared_xaxes=False,
    subplot_titles=[titles_map.get(c, c) for c in show_cols]
)
```

**⚠️ 严重问题**：
- 8个因子 → 8行 → 图表高度 = 8×220 = 1760px
- 副图比主图大得多（主图只有4行）
- 滚动阅读困难

**列标题实现** (4278-4289行)：
```python
column_labels = ['多头增量暴露', '空头增量暴露']
for idx, label in enumerate(column_labels):
    xpos = (idx + 0.5) / cols
    fig.add_annotation(text=label, x=xpos, y=1.08, ...)
```

**✅ 创新设计**：
- 使用annotation模拟列标题
- 清晰标注左右列含义

**建议布局优化**：
```python
# 方案A：分页展示（每页4个因子）
def _plot_direction_page(show_cols_subset, page_num):
    rows = len(show_cols_subset)
    fig = make_subplots(rows=rows, cols=2, ...)
    # ... 绘图逻辑
    self._save_figure_with_details(
        fig,
        name=f'factor_direction_exposure_page{page_num}_light',
        ...
    )

# 方案B：可折叠交互式图表（使用Plotly的updatemenus）
buttons = []
for col in show_cols:
    visible_mask = [False] * len(fig.data)
    # 只显示该因子的多空曲线
    visible_mask[col_start_idx:col_end_idx] = [True, True, True]
    buttons.append({
        'label': titles_map[col],
        'method': 'update',
        'args': [{'visible': visible_mask}]
    })
fig.update_layout(updatemenus=[{'buttons': buttons, ...}])
```

---

**副图2：持仓暴露** (factor_holdings_exposure_light)

**布局相同问题** (4409-4415行)：
```python
cols = 2
rows = len(show_cols)  # 同样是8行！
```

**⚠️ 与副图1相同的高度问题**

---

## ⚠️ 关键设计问题汇总

### 问题1：分钟因子快照的"向后10分钟"不对称

**当前逻辑** (3567-3573行)：
```python
merged_code = pd.merge_asof(
    left,  # 交易时刻
    right,  # 分钟因子
    left_on='Timestamp',
    right_on='datetime',
    direction='backward',  # 向后查找
    tolerance=pd.Timedelta(minutes=10)
)
```

**问题分析**：
- "买入前10分钟窗口"的描述（3428行）
- 但实际是"向后查找最近的因子值（最多10分钟前）"
- **不一致**：不是"10分钟窗口平均"，而是"最近时刻的单点值"

**示例**：
```
交易时刻：10:35:00
分钟K可用：10:25, 10:30, 10:35
当前逻辑：匹配到10:30的因子值（最近且≤5分钟前）

文档描述暗示应该：取10:25-10:35的因子均值/中位数
```

**建议修正文档或代码**：
```python
# 选项A：修正文档（推荐，代码逻辑合理）
"""基于交易时刻最近的分钟级因子快照（向后查找≤10分钟）"""

# 选项B：修正代码（实现真正的窗口平均）
# 需要额外逻辑，复杂度高，不推荐
```

---

### 问题2：分钟快照与日频因子的优先级混乱

**当前逻辑** (4016-4021行)：
```python
minute_cols = ['mom_5m', 'mom_30m', 'mom_60m', 'rv_5m', 'beta_5m', 'range_day']
for col in minute_cols:
    daily_col = f'{col}_daily'
    if daily_col in merge_df.columns:
        merge_df[col] = merge_df[col].fillna(merge_df[daily_col])  # 用日频填充分钟缺失
```

**⚠️ 与问题3的修正冲突！**

- 前面我们修正了`_build_factor_dataset()`，不再混合频率（保持NaN）
- 但在这里又用日频因子填充分钟缺失！
- **逻辑矛盾**

**需要同步修正**：
```python
# 修正：不再填充，保持分钟因子的纯净性
for col in minute_cols:
    if f'{col}_is_intraday' not in merge_df.columns:
        merge_df[f'{col}_is_intraday'] = merge_df[col].notna()
# 删除fillna逻辑
```

---

### 问题3：覆盖率统计的权重加权不准确

**当前实现** (4052-4059行)：
```python
day_total_weight = df_day['trade_weight'].sum()
for col in minute_cols:
    if day_total_weight > 0:
        covered = df_day.loc[df_day[f'{col}_is_intraday'] & df_day[col].notna(), 'trade_weight'].sum()
        covered_weights[col] += float(covered)
        total_weights[col] += float(day_total_weight)
```

**⚠️ 分母错误**：
- `total_weights[col]` 累加的是"全部交易权重"
- 但因子可能本身就缺失（不只是is_intraday=False）
- **正确分母**应该是"该因子非NaN的权重总和"

**修正方案**：
```python
# 正确统计有效样本权重
for col in minute_cols:
    # 分子：来自分钟数据且有效的权重
    covered = df_day.loc[df_day[f'{col}_is_intraday'] & df_day[col].notna(), 'trade_weight'].sum()
    # 分母：该因子非NaN的权重总和（包括分钟+日频）
    total_valid = df_day.loc[df_day[col].notna(), 'trade_weight'].sum()
    
    covered_weights[col] += float(covered)
    total_weights[col] += float(total_valid)  # 修正：只统计有效样本
```

---

### 问题4：多空暴露的符号语义不明确

**当前实现** (4048行)：
```python
direction_row[f'short_{col}'] = -_weighted_exposure(df_day, col, 'short_exposure_amount')
```

**问题场景**：
```
某日开空 momentum=+5% 的股票
short_mom_5m = -5%

如何解读？
A. "空头仓位暴露在+5%动量上，但做空所以取负" ← 当前逻辑
B. "空头仓位的有向暴露为-5%"

在图表中：
- 显示为负值
- 但用户可能误解为"空头在负动量股票上"
```

**建议**：
1. 在图表标题明确说明：
   ```python
   fig.update_layout(
       title='新增仓位多空方向分解<br><sub style="color:red;">注：空头暴露已取反，负值表示做空正动量股票</sub>'
   )
   ```

2. 或者移除负号，用图表位置区分：
   ```python
   # 左图显示多头暴露（正值）
   # 右图显示空头暴露（正值，代表做空的因子特征绝对值）
   direction_row[f'short_{col}'] = _weighted_exposure(df_day, col, 'short_exposure_amount')
   ```

---

### 问题5：持仓暴露的"净权重"可能为负

**当前实现** (4343-4347行)：
```python
merged['position_value'] = merged['position_qty'] * merged['close']
merged['long_weight'] = merged['position_value'].clip(lower=0)
merged['short_weight'] = (-merged['position_value']).clip(lower=0)
merged['abs_weight'] = merged['long_weight'] + merged['short_weight']
merged['net_weight'] = merged['position_value']  # 可正可负
```

**使用场景** (4371行)：
```python
net_row[f'strat_{col}'] = _signed_weighted(df_day, col, 'net_weight')
```

**⚠️ 潜在问题**：
```
场景：某日净持仓 = 多头100万 - 空头150万 = -50万

使用net_weight作为权重：
  factor_A: +0.5 (多头股票特征)
  factor_B: -0.3 (空头股票特征)
  
净暴露 = (+0.5×100万 - 0.3×150万) / (-50万)
       = (50万 - 45万) / (-50万)
       = -0.1
       
但实际暴露应该是：
  多头贡献：+0.5
  空头贡献：-0.3
  净效应：取决于多空仓位相对大小
```

**数学问题**：
- 当净仓位为负（空头主导）时，加权平均的符号会反转
- 导致暴露值难以解释

**建议修正**：
```python
# 使用有向加权：
def _signed_weighted(df: pd.DataFrame, col: str, weight_col: str) -> float:
    g = df.dropna(subset=[col, weight_col])
    if len(g) == 0:
        return np.nan
    
    # 分别计算多空暴露，然后按绝对值加权合成
    long_mask = g[weight_col] > 0
    short_mask = g[weight_col] < 0
    
    long_expo = 0.0
    short_expo = 0.0
    long_w_sum = g.loc[long_mask, weight_col].sum()
    short_w_sum = g.loc[short_mask, weight_col].abs().sum()
    
    if long_w_sum > 0:
        long_expo = (g.loc[long_mask, weight_col] * g.loc[long_mask, col]).sum() / long_w_sum
    if short_w_sum > 0:
        short_expo = -(g.loc[short_mask, weight_col].abs() * g.loc[short_mask, col]).sum() / short_w_sum
    
    total_abs_w = long_w_sum + short_w_sum
    if total_abs_w > 0:
        return (long_expo * long_w_sum + short_expo * short_w_sum) / total_abs_w
    return np.nan
```

---

## 📊 呈现方式评估

### 优点 ✅

1. **三层递进结构**：
   - 主图：整体暴露 vs 市场
   - 副图1：多空分解（交易口径）
   - 副图2：持仓暴露 vs 多空拆分
   - ✅ 从宏观到微观，逻辑清晰

2. **交互性**：
   - hovermode='x unified'：同一时刻多条曲线联动
   - ✅ 便于对比

3. **指标卡片**：
   - 均值、末值、相对市场
   - 覆盖率统计
   - ✅ 关键信息完整

### 不足 ⚠️

1. **图表高度问题**（最严重）：
   - 副图1/2：8因子 × 220px/因子 = 1760px
   - 在仪表板中占用过多垂直空间
   - 建议：分页或可折叠

2. **颜色一致性**：
   ```python
   # 主图：策略蓝色、市场灰色
   # 副图1：多头绿色、空头红色、净暴露蓝色
   # 副图2：净暴露蓝色、市场灰色、多头绿色、空头红色
   ```
   - ✅ 颜色编码相对一致
   - ⚠️ 但没有明确的视觉规范文档

3. **缺失数据的视觉提示不足**：
   - 当覆盖率<50%时，曲线可能断断续续
   - 当前只在说明文字中提示
   - 建议：在曲线本身添加标记（如虚线样式）

---

## 🎯 综合评估与建议修正

### 评估结论

| 维度 | 评分 | 评语 |
|------|------|------|
| **数学严谨性** | 85/100 | 加权公式正确，但极端权重未处理 |
| **经济含义** | 80/100 | 增量暴露定义合理，但符号语义需明确 |
| **前视偏差规避** | 90/100 | 时间对齐向后查找，符合实战 |
| **可视化清晰度** | 70/100 | 布局合理但副图过高，图例拥挤 |
| **文档完整性** | 85/100 | 方法说明详细，但与代码有细微不一致 |
| **性能优化** | 95/100 | 缓存机制完善，增量计算高效 |

**总体评分：84/100 - 良好**

---

### 优先修正建议（按紧迫性排序）

#### 🔴 **高优先级（立即修正）**

1. **同步修正分钟因子填充逻辑** (4016-4021行)
   ```python
   # 删除这段代码，与前面的修正保持一致
   # for col in minute_cols:
   #     if daily_col in merge_df.columns:
   #         merge_df[col] = merge_df[col].fillna(merge_df[daily_col])
   ```

2. **修正覆盖率统计的分母** (4052-4059行)
   ```python
   # 改为统计"该因子有效样本"的权重总和
   total_valid = df_day.loc[df_day[col].notna(), 'trade_weight'].sum()
   total_weights[col] += float(total_valid)
   ```

#### 🟡 **中优先级（建议修正）**

3. **明确空头暴露符号语义**
   - 在图表标题添加说明
   - 或修改为绝对值展示

4. **优化副图布局**
   - 分页展示（每页4因子）
   - 或使用折叠按钮

5. **添加匹配质量指标**
   ```python
   # 在merge_asof后记录时间差
   merged_code['match_lag'] = merged_code['Timestamp'] - merged_code['datetime']
   # 统计：<1分钟、1-5分钟、5-10分钟的占比
   ```

#### 🟢 **低优先级（增强功能）**

6. **权重Winsorize**
   - 限制单笔最大权重不超过总权重的5-10%

7. **动态市值（如果可用）**
   - 使用历史市值避免前视偏差

8. **因子标准化**
   ```python
   # 在暴露度计算前，对因子做截面标准化
   for col in factor_cols:
       factors[f'{col}_std'] = factors.groupby('date')[col].transform(
           lambda x: (x - x.mean()) / x.std() if x.std() > 0 else 0
       )
   ```

---

## 🔧 立即执行的代码修正

让我现在就修正高优先级的问题1和2：
