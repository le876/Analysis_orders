# FIFO “订单级” vs “仓位级” 的粒度问题

FIFO 会把一个真实仓位生命周期切成多段，比如：

先买 10 万股 → 加仓 5 万 → 分两次卖出；

FIFO 视角下你得到的是多笔小的 入场–出场 对。

如果你直接对这些“配对单”各自用 T/2 做窗口，会有几件事发生：

同一个大波段被拆成很多小段反复评价，某些行情被重复使用；

你得到的是“子单择时能力”，而非“整个仓位的择时能力”。

我更关心策略层面的择时（而不是成交算法级别的微观 execution），建议：

先在单个 Code 上把连续持仓的 FIFO 配对合并成 position-level 周期：

比如从仓位从 0→正→0，整个过程算一段；

段内的所有加减仓成交视为同一个“持仓周期”的微观实现。

再在这个“持仓周期”的 open,close 上定义 T，按思路做 2T 窗口 / EntryRank / ExitRank（当前实现简化为“只看事件后的 T/2”，不考虑事件前半窗）。

# 具体实现
## step1 定义每个持仓周期的 T
基于 paired_trades_fifo.parquet：

按 Code、时间排序；

在单个 Code 上按 FIFO 重建仓位变化，找到仓位从 0→非 0→回到 0 的完整周期；

对每个周期 i：

记录 open_time_i, close_time_i（都用交易时段时间）；

T_raw_i = 交易时段分钟差（按你在看板上的口径）。

约束到合理区间：
$T_{\text{eval}} = \min(\max(T, T_{\min}), T_{\max})$ 

- 例如：$T_{\min}=30$秒
- T_{\max}=1\text{ 交易日}
- 然后用T_{\text{eval}}做buy - T_eval/2, sell + T_eval/2

拆开 EntryRank 和 ExitRank 的窗口，而不是绑在同一个对称 2T。
- EntryRank 用$buy, buy + H_entry(T)$
- ExitRank 用$sell - H_pre(T), sell + H_post(T)$
- 一般 H_pre 可以取 T 的一小部分（比如 0.2T 或一个固定的 1~2 天），H_post 取 T 或 0.5T

## step2 定义评估窗口
Entry 窗口（当前实现）：\[t^{\text{E}}_{\text{start}}, t^{\text{E}}_{\text{end}}\] = \([\text{open\_time}_i, \text{close\_time}_i]\)。
Exit 窗口（当前实现）：\[t^{\text{X}}_{\text{start}}, t^{\text{X}}_{\text{end}}\] = \([\text{open\_time}_i, \text{close\_time}_i + 0.5\, T_i]\)。
边界裁剪（避免与相邻持仓重叠）：若 \(\text{prev\_close}_i\) 存在，则 \(t^{\text{start}} = \max(t^{\text{start}}, \text{prev\_close}_i)\)；若 \(\text{next\_open}_i\) 存在，则 \(t^{\text{end}} = \min(t^{\text{end}}, \text{next\_open}_i)\)。对 Entry/Exit 窗口分别应用。

## Step 3：用 Tushare 行情算 EntryRank / ExitRank
拿到分钟 K 或 Tick 之后，每个 Code、每个周期：

在 Entry 窗口内：$P^{\text{E}}_{\min} = \min \text{Price}, P^{\text{E}}_{\max} = \max \text{Price}$
- 买入价格P_{\text{buy}}
可以定义，例如（对多头）：
$$\text{EntryRank}_i =
\begin{cases}
\frac{P_{\text{buy}} - P^{\text{E}}_{\min}}{P^{\text{E}}_{\max} - P^{\text{E}}_{\min}}, & \text{若区间有波动} \\
0.5, & \text{若 } P^{\text{E}}_{\max} = P^{\text{E}}_{\min}
\end{cases}$$
越接近 0 表示越接近区间最低价（择时好），接近 1 表示买在该区间高位（择时差）。
在 Exit 窗口内：P^{\text{X}}_{\min}, P^{\text{X}}_{\max}
- 卖出价格P_{\text{sell}}
- 一个常见定义是：
$$\text{ExitRank}_i =
\begin{cases}
\frac{P^{\text{X}}_{\max} - P_{\text{sell}}}{P^{\text{X}}_{\max} - P^{\text{X}}_{\min}}, & \text{多头} \\
\text{反过来定义}, & \text{空头}
\end{cases}$$
这样 ExitRank 越小表示卖得越靠近最高价（好），越大表示离高点越远（差）。

最后可以看：

EntryRank / ExitRank 的整体分布、均值、中位数、按 pred 分组的分布；

跟一个“随机时间进出”的模拟对比，看是否显著优于随机。


# 统一时间尺子 T_alpha + 有边界 2T_alpha 窗口下的 Entry/ExitRank 计算方案

## 0. 数据准备

### 0.1 读取 FIFO 配对成交数据

- 输入文件：`data/paired_trades_fifo.parquet`
- 保证至少包含以下字段（若字段名不同请做重命名）：
  - `Code`：标的代码
  - `side`：方向，`B`=先买后卖（多头），`S`=先卖后买（空头）
  - `open_ts`：开仓时间（pandas.Timestamp，交易时区）
  - `close_ts`：平仓时间（pandas.Timestamp，交易时区）
  - `open_price`：开仓成交均价
  - `close_price`：平仓成交均价
  - （可选）`qty`：交易数量
  - （可选）`holding_minutes_trading`：按 **交易时段分钟** 计算的持仓时长；若没有，则需要根据交易日历和 `open_ts`/`close_ts` 计算。

### 0.2 读取行情数据

- 需要一个分钟级（或更高频）的行情数据源，例如：
  - 本地文件：`minute_ohlcv.parquet`，包含字段：
    - `Code`, `Datetime`, `open`, `high`, `low`, `close`
  - 或通过 Tushare 动态拉取分钟线。
- 要求：
  - `Datetime` 能与 `open_ts`/`close_ts` 对齐；
  - 一个窗口内的价格序列，能够用 `high/low` 近似可达极值。

---

## 1. 计算统一时间尺子 T_alpha

### 1.1 计算每个 cycle 的交易时段持仓时长 H_i（分钟）

- 若已有 `holding_minutes_trading` 字段，可以直接使用；
- 否则：
  1. 根据交易所日历，将 `open_ts`/`close_ts` 映射到“交易分钟索引”（排除午休与非交易时段）；
  2. H_i = 索引差值。

### 1.2 选择分位数 alpha 并得到 T_alpha

- 对所有闭合持仓的 H_i 计算分位数：
  - e.g. `q05, q25, q50, q75, q95 = H.quantile([0.05,0.25,0.5,0.75,0.95])`
- 选择一两个候选 α 值，例如：
  - α ∈ {0.5, 0.6, 0.7}
- 对应：
  - `T_050 = quantile(H_i, 0.50)`
  - `T_060 = quantile(H_i, 0.60)`
  - `T_070 = quantile(H_i, 0.70)`
- 暂定一个主用值：
  - 例如：`T_alpha = T_060` 或 `T_070`
- 后续可以用多个 T_alpha 做敏感性分析，这里只需先实现一版。

---

## 2. 为每个 cycle 构造“有边界的 2T_alpha 窗口”

### 2.1 按 Code + open_ts 排序，并计算前一平仓 / 下一开仓时间

- 按 `Code`, `open_ts` 升序排序所有 cycle。
- 对同一 `Code` 分组，在组内做：
  - `prev_close_ts`：上一行的 `close_ts`（若不存在，用该 cycle 所在交易日的开市时间，或全局回测起点）。
  - `next_open_ts`：下一行的 `open_ts`（若不存在，用该 cycle 所在交易日的收市时间，或全局回测终点）。

### 2.2 为每一行定义窗口起止时间

给定统一时间尺度 `T_alpha`（单位：交易分钟），对每个 cycle i：

- 计算：
  - `window_start_i_raw = open_ts_i - T_alpha/2 (以交易分钟为单位平移)`
  - `window_end_i_raw   = close_ts_i + T_alpha/2`
- 应用边界裁剪（避免窗口跨越其他持仓周期）：
  - `window_start_i = max(window_start_i_raw, prev_close_ts_i)`
  - `window_end_i   = min(window_end_i_raw,   next_open_ts_i)`
- （可选）再与交易日开收市时间裁剪到同一交易日范围内。

最终得到每个 cycle 的评估窗口：
- `[window_start_i, window_end_i]`

将这些字段追加到 `paired_trades_fifo` 表中。

---

## 3. 提取窗口内价格路径并计算极值

### 3.1 为每个 cycle 拉取窗口行情

对于每一行 cycle i：

1. 从行情表中过滤该 `Code` 且 `Datetime` 落在 `[window_start_i, window_end_i]` 的所有行：
   - 得到局部价格序列 `P_t`，至少包含 `high` 和 `low`。
2. 若该窗口内没有任何行情（异常情况），可以：
   - 标记为无效样本，后续在聚合时丢弃；或
   - 退化为只用 `open_price_i` / `close_price_i` 自身作为极值（不推荐）。

### 3.2 计算窗口极值 P_min / P_max

在每个窗口内：

- `P_min_i = min(window_low_t)`  （或用 bid/ask 更精细的近似）
- `P_max_i = max(window_high_t)`

为避免数值问题，定义一个小的 `epsilon`：
- `eps = 1e-6` 或价格精度级别。

---

## 4. 计算每笔交易的 EntryRank 和 ExitRank

### 4.1 多头 cycle（side = 'B'，先买后卖）

设该行中：

- `P_entry = open_price`
- `P_exit  = close_price`
- 使用前文的 `P_min_i`, `P_max_i` 与 `eps`。

则：

```python
denom = max(P_max_i - P_min_i, eps)

EntryRank_long_i = (P_entry - P_min_i) / denom      # 越小越好，0=窗口最低
ExitRank_long_i  = (P_max_i - P_exit)  / denom      # 越小越好，0=窗口最高

---

# 页面实现与近期修改记录

## 现状（2025-12-06）
- 页面文件：`reports/entry_exit_rank_baostock_full.html`（复制到 `reports/visualization_analysis/` 与 `docs/` 用于索引/预览）。
- 数据来源：`data/paired_trades_fifo.parquet` 配对成交 + `data/cache/baostock_5min/*.parquet` 行情缓存；结果缓存 `data/cache/entry_exit_rank_baostock_result.json`（`--recompute` 可强制重算）。
- 核心指标：全体/超短 EntryRank & ExitRank，支持笔数、成交金额加权、PnL 加权；增加 Edge 捕获率（持仓期间波动覆盖度）及基准线（优先使用经验基准，缺样本时回退均匀基准）。
- 并行：默认读取缓存后可用 `--workers N` 启用 `ProcessPoolExecutor`。

## 实现方式（图表计算说明）
- 统一窗口：全体交易用 `Tα_global=234` 分钟，超短单（持仓≤10 分钟）用 `Tα_short=5` 分钟；均使用 5 分钟 K 线（high/low/open/close），并在同一标的上用前一平仓时刻 `prev_close` 与下一开仓时刻 `next_open` 对窗口裁剪，避免跨越相邻持仓。
- EntryRank / ExitRank：对多头定义为 `EntryRank = (买价 - 窗口内最低价) / (窗口内最高价 - 窗口内最低价)`，`ExitRank = (窗口内最高价 - 卖价) / (窗口内最高价 - 窗口内最低价)`；空头方向镜像（买入/卖出对调并翻转计算），无波动时置为 0.5。Rank∈[0,1]，越接近 0 表示越优。
- Edge 捕获率：在实际持仓区间内（open→close）计算 `(平仓价 - 开仓价) / (区间内最高价 - 最低价)`，空头镜像，裁剪到 [0,1]；衡量吃到的波动占比。
- 直方图视图：
  - Rank·笔数：Entry/ExitRank 以笔数加权的分布直方图，叠加经验基准线（同窗口随机抽一根 5m K 线并在 High/Low 内随机取价计算 Rank，累积成分布；若不足则回退 1/桶数均匀线）与中位数虚线。
  - Rank·金额权重：按成交金额（开仓价×数量）加权的 Rank 分布。
  - Rank·PnL 权重：两种口径——**盈利部分**（max(PnL,0)，强调赚钱单贡献）与 **含亏损**（|PnL|，让亏损单按亏损绝对额参与权重，避免负权重被过滤）；按钮切换。
  - Edge·笔数 / 金额 / PnL 权重：与 Rank 类似，其中 PnL 视角同样区分盈利部分 vs 含亏损。
- 按钮切换：同一模块内多种视角（Rank/Edge，笔数/金额/PnL）通过按钮互斥显示，默认首个视图可见。
- 统计概览：每个模块下方给出 Entry/Exit 的样本量、均值、中位数、P25/P75；顶部卡片给出全体均值、完美买/卖占比（Rank<0.1，对应均匀基准≈10%，经验基准接近但由实际窗口行情抽样）。

## 近期问题与解决方案
- 问题：图表空白。多次调整布局/按钮切换后仍无效，控制台仅提示 tailwind CDN/plotly 警告，无直接报错。原因是 Plotly HTML 里包含 `dtype/bdata` typed array（`fig.to_html` 的输出），部分浏览器在本地文件载入时拒绝解析/渲染，导致图像不显示。
- 再现场景：本地 file:// 预览或简易 HTTP 服务下，Plotly v2 对 typed array 的序列化在部分环境被拦截，图容器为空白且无报错。
- 解决：改为手动序列化 Plotly 图对象，递归转为原生 Python list/float（`_to_plain`），生成 `<div>` + `Plotly.newPlot` 脚本注入页面，去掉 typed array；在脚本外包裹 try/catch，渲染异常在控制台输出 “Plotly render error” 并在容器内显示错误文本。按钮切换仍保留，默认首个视图显示。
- 经验/防止重犯：避免直接用 `fig.to_html` 嵌入；优先 `to_plotly_json` + 手写 `Plotly.newPlot`；检查 HTML 是否含 `"bdata"`/`"dtype"`。若再次空白，控制台搜 “Plotly render error” 定位问题。
- 未解决/可忽略：`cdn.tailwindcss.com` 生产环境警告、favicon 404、DevTools 自动探测 `.well-known` 404，不影响图表渲染。

## 历史记录（重点）
- 2025-12-06：多次修改后图表仍空白，最终通过去除 typed array、改为手动 `Plotly.newPlot` 修复；保留结果缓存和按钮切换。之前的几次修改只调整布局/按钮，未消除 typed array，故未生效。

## 开发备注：baostock 5min 择时分布页面

- 生成脚本：`scripts/run_entry_exit_rank_baostock.py`。默认先查结果缓存 `data/cache/entry_exit_rank_baostock_result.json`，存在即直接生成页面，避免再次读取 5min 行情与全量循环。  
- 行情缓存：`data/cache/baostock_5min/{code}.parquet`，缺失才登录 baostock。  
- 强制重算（算法/窗口改动或需要刷新样本）：`python scripts/run_entry_exit_rank_baostock.py --recompute`（或删除结果缓存文件后再运行）。  
- 页面输出：`reports/entry_exit_rank_baostock_full.html`（自动同步到 `reports/visualization_analysis/` 与 `docs/`）。  
- 说明：结果缓存只存分箱统计与摘要，不存原始数组；如更换 Tα 或 Rank 计算方式，务必重算以避免旧结果沿用。

# 页面优化设计方案 (Design Proposal)

本章节旨在指导如何重构 `entry_exit_rank_baostock_full.html`，使其成为一个专业、高颜值且信息密度高的量化分析仪表盘。

## 1. 设计理念与目标
*   **专业性**：摒弃简单的“堆叠图表”，采用 Dashboard 布局，核心指标优先。
*   **清晰性**：区分 Entry（买入/成本）与 Exit（卖出/收益）的视觉语义。
*   **对比性**：始终与“随机择时”（Uniform Distribution）进行对比，凸显 alpha。

## 2. 布局架构 (Grid System)
采用 Tailwind CSS 的响应式网格布局。

### 2.1 顶部 KPI 栏 (KPI Cards)
横向排列 4 个关键指标卡片：
1.  **平均 Entry Rank**: 越低越好。目标 < 0.5。
    *   颜色：绿色系 (Teal/Emerald) -> 代表“低成本买入”。
2.  **平均 Exit Rank**: 越低越好（注：定义为距最高点的距离）。目标 < 0.5。
    *   颜色：红色系 (Rose/Red) -> 代表“高位卖出获利”。
3.  **完美买入占比 (Rank < 0.1)**: 买在最低 10% 价格区间的比例。
    *   目标 > 10% (随机基准)。
4.  **完美卖出占比 (Rank < 0.1)**: 卖在最高 10% 价格区间的比例。
    *   目标 > 10% (随机基准)。

### 2.2 主图表区 (2x2 Grid)
*   **Row 1: 核心分布 (Distribution)**
    *   **Left**: Entry Rank 分布直方图 (Histogram)。叠加 KDE 曲线。
        *   颜色：`#10b981` (Emerald-500)。
        *   基准线：`y=1` (均匀分布水平线，灰色虚线)。
    *   **Right**: Exit Rank 分布直方图 (Histogram)。叠加 KDE 曲线。
        *   颜色：`#f43f5e` (Rose-500)。
        *   基准线：同上。

*   **Row 2: 深度分析 (Deep Dive)**
    *   **Left**: Rank 随持仓时间的变化 (Scatter/Box)。
        *   X轴：持仓时长 (log scale)；Y轴：Entry/Exit Rank。
        *   目的：观察是否“拿得越久，择时越差/越好”。
    *   **Right**: 不同预测分位组 (Pred Quantile) 的 Rank 表现 (Bar/Box)。
        *   X轴：G1 (Low Pred) -> G10 (High Pred)。
        *   Y轴：平均 Rank。
        *   目的：验证模型预测值高的时候，择时是否也更好。

## 3. 配色系统 (Color Semantics)
严格遵守以下语义，避免混淆：
*   **Entry (买入动作)**:
    *   主色：`#10b981` (Emerald-500)。
    *   背景色：`bg-emerald-50`。
    *   语义：买入寻求低价 -> 绿色在 A 股代表下跌/低价 -> **逻辑自洽**。
*   **Exit (卖出动作)**:
    *   主色：`#f43f5e` (Rose-500)。
    *   背景色：`bg-rose-50`。
    *   语义：卖出寻求高价 -> 红色在 A 股代表上涨/高价 -> **逻辑自洽**。
*   **Neutral (基准/随机)**:
    *   颜色：`#9ca3af` (Gray-400)。

## 4. 实施步骤 (Instructions for Codex)

### Step 1: 数据结构重组
在 `scripts/run_entry_exit_rank_baostock.py` 中，确保计算并传递以下聚合数据到 HTML 生成函数：
*   全量 Rank 数组（或高精度的 histogram bins），用于绘制平滑分布。
*   按 Pred 分组的 Rank 均值。
*   按持仓时长分组的 Rank 均值。

### Step 2: HTML 模板重写
完全重写 `_generate_html_report` 函数中的 HTML 字符串构建逻辑。
*   **引入库**:
    ```html
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    ```
*   **容器**: 使用 `<div class="max-w-7xl mx-auto p-6 space-y-8">`。

### Step 3: Plotly 图表配置
*   **Layout**: `paper_bgcolor='rgba(0,0,0,0)'`, `plot_bgcolor='rgba(0,0,0,0)'`。
*   **Font**: `family="Inter, sans-serif"`, `color="#374151"`。
*   **Margin**: `l=40, r=20, t=40, b=40`。
*   **Legend**: `orientation="h", y=1.1`。

### Step 4: 替换现有逻辑
找到脚本中的 HTML 生成部分，用新的 Tailwind Grid 布局替换旧的简单布局。
确保所有 Emoji 被 FontAwesome 图标 (`<i class="fas ..."></i>`) 替代。

## 修改历史
- 2025-02-07：按《可视化页面设计准则》重写页面结构，采用 Tailwind 仪表盘布局、sticky 页眉、主容器 `max-w-7xl`，说明文字面向用户（去除缓存/开发信息），配色改为 A 股语义（Entry 绿、Exit 红，随机基准灰）。将样本概览置于分布图下方，默认锚点跳转到主图，满足 index 预览聚焦主图要求。
- 2025-02-07：在 Entry/Exit 合并直方图上叠加基准线（优先经验基准，缺样本回退均匀 1/桶数），用于直观对比是否存在超额择时能力（Alpha）。保持预聚合分箱与结果缓存，页面仍可直接嵌入 index。
- 2025-02-07：新增成交金额加权 / PnL 加权 Rank 分布，以及 Edge 捕获率（区间波动捕获度）指标；页面内通过按钮切换视图（笔数、金额权重、PnL 权重，含全体与超短单）。结果缓存结构扩展存储多种权重分布。
- 2025-02-07：生成脚本改为多进程并行（ProcessPoolExecutor），`--workers` 建议 4~6，缓存齐全时显著提速；仍保留结果缓存加速后续生成。
- 2025-02-07：修复图像不显示的问题——原因是 f-string 中内嵌的 JS 被转义/覆盖，导致 Plotly div 隐藏；将交互脚本提取为 `script_block` 并用占位符插入，确保 HTML 正确注入脚本，直方图正常渲染与 resize。
- 2025-02-07：再次修复图像初始隐藏问题——模式切换的按钮和图表初始态未设置 active/display，导致页面加载时所有图表隐藏。修复方式：默认首个按钮 active，首个图表 display:block，初始化逻辑如无 active 则自动选第一项，并在切换/resize 时调用 Plotly.resize。
- 2025-02-XX：Plotly 依赖 CDN 会导致图像空白。已在 `docs/assets/plotly-2.27.0.min.js` 放置本地版本，并在页面中先加载本地、再回退 CDN。后续更新页面时务必保留该本地脚本引用，否则离线/代理环境下图会消失。
