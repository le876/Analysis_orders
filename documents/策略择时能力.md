# FIFO “订单级” vs “仓位级” 的粒度问题

FIFO 会把一个真实仓位生命周期切成多段，比如：

先买 10 万股 → 加仓 5 万 → 分两次卖出；

FIFO 视角下你得到的是多笔小的 入场–出场 对。

如果你直接对这些“配对单”各自用 T/2 做窗口，会有几件事发生：

同一个大波段被拆成很多小段反复评价，某些行情被重复使用；

你得到的是“子单择时能力”，而非“整个仓位的择时能力”。

我更关心策略层面的择时（而不是成交算法级别的微观 execution），建议：

先在单个 Code 上把连续持仓的 FIFO 配对合并成 position-level 周期：

比如从仓位从 0→正→0，整个过程算一段；

段内的所有加减仓成交视为同一个“持仓周期”的微观实现。

再在这个“持仓周期”的 open,close 上定义 T，再按思路做 2T 窗口 / EntryRank / ExitRank。

# 具体实现
## step1 定义每个持仓周期的 T
基于 paired_trades_fifo.parquet：

按 Code、时间排序；

在单个 Code 上按 FIFO 重建仓位变化，找到仓位从 0→非 0→回到 0 的完整周期；

对每个周期 i：

记录 open_time_i, close_time_i（都用交易时段时间）；

T_raw_i = 交易时段分钟差（按你在看板上的口径）。

约束到合理区间：
$T_{\text{eval}} = \min(\max(T, T_{\min}), T_{\max})$

- 例如：$T_{\min}=30$秒
- T_{\max}=1\text{ 交易日}
- 然后用T_{\text{eval}}做buy - T_eval/2, sell + T_eval/2

拆开 EntryRank 和 ExitRank 的窗口，而不是绑在同一个对称 2T。
- EntryRank 用$buy, buy + H_entry(T)$
- ExitRank 用$sell - H_pre(T), sell + H_post(T)$
- 一般 H_pre 可以取 T 的一小部分（比如 0.2T 或一个固定的 1~2 天），H_post 取 T 或 0.5T

## step2 定义评估窗口
Entry 窗口（只看未来）：
$$[t^{\text{E}}_{\text{start}}, t^{\text{E}}_{\text{end}}]
= [\text{open\_time}_i, \text{open\_time}_i + \alpha T_i]$$
举例：

β = 0.2（看卖前 20% 的持仓时间，有没有提前砍掉神仙走势）；

γ = 1.0（卖后再给你一个 T 的机会，看有没有明显冲高）。

再用你刚才的「前一笔卖出 / 下一笔买入」规则做截断：
若 t^{\text{E}}_{\text{start}}早于上一笔该 Code 的 close_time，则设t^{\text{E}}_{\text{start}} = \text{last\_close}_i^+
若 t^{\text{X}}_{\text{end}} = \text{next\_open}_i^-晚于下一笔该 Code 的 open_time，则设t^{\text{X}}_{\text{end}} = \text{next\_open}_i^-

## Step 3：用 Tushare 行情算 EntryRank / ExitRank
拿到分钟 K 或 Tick 之后，每个 Code、每个周期：

在 Entry 窗口内：$P^{\text{E}}_{\min} = \min \text{Price}, P^{\text{E}}_{\max} = \max \text{Price}$
- 买入价格P_{\text{buy}}
可以定义，例如（对多头）：
$$\text{EntryRank}_i =
\begin{cases}
\frac{P_{\text{buy}} - P^{\text{E}}_{\min}}{P^{\text{E}}_{\max} - P^{\text{E}}_{\min}}, & \text{若区间有波动} \\
0.5, & \text{若 } P^{\text{E}}_{\max} = P^{\text{E}}_{\min}
\end{cases}$$
越接近 0 表示越接近区间最低价（择时好），接近 1 表示买在该区间高位（择时差）。
在 Exit 窗口内：P^{\text{X}}_{\min}, P^{\text{X}}_{\max}
- 卖出价格P_{\text{sell}}
- 一个常见定义是：
$$\text{ExitRank}_i =
\begin{cases}
\frac{P^{\text{X}}_{\max} - P_{\text{sell}}}{P^{\text{X}}_{\max} - P^{\text{X}}_{\min}}, & \text{多头} \\
\text{反过来定义}, & \text{空头}
\end{cases}$$
这样 ExitRank 越小表示卖得越靠近最高价（好），越大表示离高点越远（差）。

最后可以看：

EntryRank / ExitRank 的整体分布、均值、中位数、按 pred 分组的分布；

跟一个“随机时间进出”的模拟对比，看是否显著优于随机。


# 统一时间尺子 T_alpha + 有边界 2T_alpha 窗口下的 Entry/ExitRank 计算方案

## 0. 数据准备

### 0.1 读取 FIFO 配对成交数据

- 输入文件：`data/paired_trades_fifo.parquet`
- 保证至少包含以下字段（若字段名不同请做重命名）：
  - `Code`：标的代码
  - `side`：方向，`B`=先买后卖（多头），`S`=先卖后买（空头）
  - `open_ts`：开仓时间（pandas.Timestamp，交易时区）
  - `close_ts`：平仓时间（pandas.Timestamp，交易时区）
  - `open_price`：开仓成交均价
  - `close_price`：平仓成交均价
  - （可选）`qty`：交易数量
  - （可选）`holding_minutes_trading`：按 **交易时段分钟** 计算的持仓时长；若没有，则需要根据交易日历和 `open_ts`/`close_ts` 计算。

### 0.2 读取行情数据

- 需要一个分钟级（或更高频）的行情数据源，例如：
  - 本地文件：`minute_ohlcv.parquet`，包含字段：
    - `Code`, `Datetime`, `open`, `high`, `low`, `close`
  - 或通过 Tushare 动态拉取分钟线。
- 要求：
  - `Datetime` 能与 `open_ts`/`close_ts` 对齐；
  - 一个窗口内的价格序列，能够用 `high/low` 近似可达极值。

---

## 1. 计算统一时间尺子 T_alpha

### 1.1 计算每个 cycle 的交易时段持仓时长 H_i（分钟）

- 若已有 `holding_minutes_trading` 字段，可以直接使用；
- 否则：
  1. 根据交易所日历，将 `open_ts`/`close_ts` 映射到“交易分钟索引”（排除午休与非交易时段）；
  2. H_i = 索引差值。

### 1.2 选择分位数 alpha 并得到 T_alpha

- 对所有闭合持仓的 H_i 计算分位数：
  - e.g. `q05, q25, q50, q75, q95 = H.quantile([0.05,0.25,0.5,0.75,0.95])`
- 选择一两个候选 α 值，例如：
  - α ∈ {0.5, 0.6, 0.7}
- 对应：
  - `T_050 = quantile(H_i, 0.50)`
  - `T_060 = quantile(H_i, 0.60)`
  - `T_070 = quantile(H_i, 0.70)`
- 暂定一个主用值：
  - 例如：`T_alpha = T_060` 或 `T_070`
- 后续可以用多个 T_alpha 做敏感性分析，这里只需先实现一版。

---

## 2. 为每个 cycle 构造“有边界的 2T_alpha 窗口”

### 2.1 按 Code + open_ts 排序，并计算前一平仓 / 下一开仓时间

- 按 `Code`, `open_ts` 升序排序所有 cycle。
- 对同一 `Code` 分组，在组内做：
  - `prev_close_ts`：上一行的 `close_ts`（若不存在，用该 cycle 所在交易日的开市时间，或全局回测起点）。
  - `next_open_ts`：下一行的 `open_ts`（若不存在，用该 cycle 所在交易日的收市时间，或全局回测终点）。

### 2.2 为每一行定义窗口起止时间

给定统一时间尺度 `T_alpha`（单位：交易分钟），对每个 cycle i：

- 计算：
  - `window_start_i_raw = open_ts_i - T_alpha/2 (以交易分钟为单位平移)`
  - `window_end_i_raw   = close_ts_i + T_alpha/2`
- 应用边界裁剪（避免窗口跨越其他持仓周期）：
  - `window_start_i = max(window_start_i_raw, prev_close_ts_i)`
  - `window_end_i   = min(window_end_i_raw,   next_open_ts_i)`
- （可选）再与交易日开收市时间裁剪到同一交易日范围内。

最终得到每个 cycle 的评估窗口：
- `[window_start_i, window_end_i]`

将这些字段追加到 `paired_trades_fifo` 表中。

---

## 3. 提取窗口内价格路径并计算极值

### 3.1 为每个 cycle 拉取窗口行情

对于每一行 cycle i：

1. 从行情表中过滤该 `Code` 且 `Datetime` 落在 `[window_start_i, window_end_i]` 的所有行：
   - 得到局部价格序列 `P_t`，至少包含 `high` 和 `low`。
2. 若该窗口内没有任何行情（异常情况），可以：
   - 标记为无效样本，后续在聚合时丢弃；或
   - 退化为只用 `open_price_i` / `close_price_i` 自身作为极值（不推荐）。

### 3.2 计算窗口极值 P_min / P_max

在每个窗口内：

- `P_min_i = min(window_low_t)`  （或用 bid/ask 更精细的近似）
- `P_max_i = max(window_high_t)`

为避免数值问题，定义一个小的 `epsilon`：
- `eps = 1e-6` 或价格精度级别。

---

## 4. 计算每笔交易的 EntryRank 和 ExitRank

### 4.1 多头 cycle（side = 'B'，先买后卖）

设该行中：

- `P_entry = open_price`
- `P_exit  = close_price`
- 使用前文的 `P_min_i`, `P_max_i` 与 `eps`。

则：

```python
denom = max(P_max_i - P_min_i, eps)

EntryRank_long_i = (P_entry - P_min_i) / denom      # 越小越好，0=窗口最低
ExitRank_long_i  = (P_max_i - P_exit)  / denom      # 越小越好，0=窗口最高

---

## 开发备注：baostock 5min 择时分布页面

- 生成脚本：`scripts/run_entry_exit_rank_baostock.py`。默认先查结果缓存 `data/cache/entry_exit_rank_baostock_result.json`，存在即直接生成页面，避免再次读取 5min 行情与全量循环。  
- 行情缓存：`data/cache/baostock_5min/{code}.parquet`，缺失才登录 baostock。  
- 强制重算（算法/窗口改动或需要刷新样本）：`python scripts/run_entry_exit_rank_baostock.py --recompute`（或删除结果缓存文件后再运行）。  
- 页面输出：`reports/entry_exit_rank_baostock_full.html`（自动同步到 `reports/visualization_analysis/` 与 `docs/`）。  
- 说明：结果缓存只存分箱统计与摘要，不存原始数组；如更换 Tα 或 Rank 计算方式，务必重算以避免旧结果沿用。
